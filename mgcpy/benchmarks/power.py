import numpy as np
import math
from mgcpy.independence_tests.dcorr import DCorr


def power(independence_test, sample_generator, num_samples=100, num_dimensions=1, repeats=1000, alpha=.05):
    '''
    Estimate power

    :param independence_test: an object whose class inherits from the Independence_Test abstract class
    :type: Object(Independence_Test)
    :param sample_generator: a function used to generate simulation from simulations.py
    :type: function
    :param num_samples: the number of samples generated by the simulation
    :type: int
    :param num_dimensions: the number of dimensions of the samples generated by the simulation
    :type: int
    :param repeats: the number of times we generate new samples to estimate the null/alternative distribution
    :type: int
    :param alpha: the type I error level
    :type: float
    '''

    # test statistics under the null, used to estimate the cutoff value under the null distribution
    test_stats_null = np.zeros(repeats)
    # test statistic under the alternative
    test_stats_alternative = np.zeros(repeats)
    for rep in range(repeats):
        # generate new samples for each iteration
        data_matrix_X, data_matrix_Y = sample_generator(num_samples, num_dimensions, noise=0)
        # to make the data format conformed
        data_matrix_Y = data_matrix_Y[:, np.newaxis]
        # permutation test
        permuted_y = np.random.permutation(data_matrix_Y)
        test_stats_null[rep] = independence_test.test_statistic(data_matrix_X=data_matrix_X, data_matrix_Y=permuted_y)
        test_stats_alternative[rep] = independence_test.test_statistic(data_matrix_X=data_matrix_X, data_matrix_Y=data_matrix_Y)

    # the cutoff is determined so that 1-alpha of the test statistics under the null distribution
    # is less than the cutoff
    cutoff = np.sort(test_stats_null)[math.ceil(repeats*(1-alpha))]
    # the proportion of test statistics under the alternative which is no less than the cutoff (in which case
    # the null is rejected) is the empirical power
    empirical_power = np.where(test_stats_alternative >= cutoff)[0].shape[0] / repeats
    return empirical_power

    '''
        if the correlation test is mcorr, we can leverage the t-test
        instead of having to estimate the null distribution
        # deal with this case later
        if num_samples < 4:
            print('Not enough samples')
            return None
        v = num_samples*(num_samples-3)/2
        # the boundary of the rejection regions, reject null if the test statistic is more extreme
        negative_cutoff, positive_cutoff = t.interval(1-alpha/2, df=v-1)
        # count the number of time the test rejects the null hypothesis
        count_reject_null = 0
        for rep in range(repeats):
            # generate new samples for each iteration
            data_matrix_X, data_matrix_Y = sample_generator(num_samples, num_dimensions)
            # to make the data format conformed
            data_matrix_Y = data_matrix_Y[:, np.newaxis]
            T, df = self.mcorr_T(data_matrix_X, data_matrix_Y)
            if T <= negative_cutoff or T >= positive_cutoff:
                count_reject_null += 1
        return count_reject_null / repeats
    '''
